"""This script will perform the fov-fov normalization scheme that was generated by Yunhao Bai and Sizun Jiang. In short
fovs for each sample are read in. The HH3 single is taken from the nuclear area of each image (defined by the nuclear
segmentation mask. The mean HH3 signal from those regions for each fov is stored in a vector. This vector is then divided
by the maximum value to get a transformation coefficient for each fov. Then each image channel for each fov is divided
by this coefficient to correct for variations observed in the data. The output is stored as 32-bit images."""

import os
import numpy as np
import pandas as pd
import skimage.io as io
from tmi import io_utils
import erin_utils
from natsort import natsorted

# define directories

# base directory for samples
base_dir = '/Volumes/T7 Shield/MIBI_data/NHP_TB_Panel1/Panel1'
segmentation_dir = os.path.join(base_dir, 'segmentation_nuc', 'deepcell_output')
necrosis_dir = os.path.join(base_dir, 'masks', 'necrosis_masks')
cell_dir = os.path.join(base_dir, 'masks', 'cellular_masks')
output_dir = os.path.join(base_dir, 'tile_corrected/image_data')
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

# run_dir
data_dir = os.path.join(base_dir, 'normalized', 'image_data')

# load in mapping/sample information
fov_mapping = pd.read_csv(os.path.join(base_dir, 'keys/fov_position_mapping.csv'))

# get samples
samples = fov_mapping['sample'].unique().tolist()
samples_noMo = [i for i in samples if i != 'Moly']
samples_sorted = natsorted(samples_noMo)

# define information to use for correction
seg_suffix = '_nuclear.tiff'
correction_channels_nec = ['CD45.tiff']
correction_channels_cell = ['HH3.tiff']
norm_const = 200

for sample in samples_sorted:

    print("Working on sample: " + sample)

    # get list of the fovs, store as vector
    sample_fovs = io_utils.list_folders(data_dir, substrs=['sample' + sample + '_'])

    # read in necrosis mask
    necrosis_mask = io.imread(os.path.join(necrosis_dir, 'sample' + sample, 'Sample' + sample + '_Panel1_Necrosis.tif'))
    cellular_mask = io.imread(os.path.join(cell_dir, 'sample' + sample + '_cellular_mask.png'))

    # function that returns vector mean nuclear HH3 for fovs
    mean_cell_values, mean_necrosis_values = erin_utils.get_mean_correction_signal(data_dir,
                                                                                   segmentation_dir,
                                                                                   sample_fovs,
                                                                                   correction_channels_nec,
                                                                                   correction_channels_cell,
                                                                                   necrosis_mask,
                                                                                   cellular_mask,
                                                                                   seg_suffix)

    # define max of vector and get correction coefficients
    max_value_cell = np.nanmax(mean_cell_values)
    correction_coefficients_cell = np.divide(mean_cell_values, max_value_cell)

    max_value_nec = np.nanmax(mean_necrosis_values)
    correction_coefficients_nec = np.divide(mean_necrosis_values, max_value_nec)

    # loop over fovs and channels, correct and export
    for i in range(len(sample_fovs)):

        # define fov
        fov = sample_fovs[i]
        print("Working on: " + fov)

        # define path to fov and output dir
        fov_dir = os.path.join(data_dir, fov)
        fov_output_dir = os.path.join(output_dir, fov)
        if not os.path.exists(fov_output_dir):
            os.makedirs(fov_output_dir)

        # define channels to work on
        channels = io_utils.list_files(fov_dir, substrs=[".tiff"])

        # get the necrosis and cell crops
        nec_mask = erin_utils.crop_mask(necrosis_mask, fov, im_size=1024)
        cell_mask = erin_utils.crop_mask(cellular_mask, fov, im_size=1024)

        # get coefficients
        coeff_cell = correction_coefficients_cell[i]
        coeff_nec = correction_coefficients_nec[i]

        for channel in channels:

            # read in channel data
            channel_data = io.imread(os.path.join(fov_dir, channel))

            # transform
            channel_data_corrected = np.copy(channel_data)
            if not pd.isna(coeff_nec):
                channel_data_corrected[np.where(nec_mask)] = channel_data_corrected[np.where(nec_mask)] / coeff_nec
            if not pd.isna(coeff_cell):
                channel_data_corrected[np.where(cell_mask)] = channel_data_corrected[np.where(cell_mask)] / coeff_cell

            channel_data_norm = channel_data_corrected / norm_const

            # export
            io.imsave(os.path.join(fov_output_dir, channel), channel_data_norm, check_contrast=False)
